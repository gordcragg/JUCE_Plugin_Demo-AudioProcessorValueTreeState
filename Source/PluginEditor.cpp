/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================


//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor& owner)
    : AudioProcessorEditor (owner),
      midiKeyboard (owner.keyboardState, MidiKeyboardComponent::horizontalKeyboard),
      timecodeDisplayLabel (String()),
      gainLabel (String(), "Throughput level:"),
      delayLabel (String(), "Delay:")
{
    // add some sliders..
    addAndMakeVisible (gainSlider = new Slider());
    gainSlider->setSliderStyle (Slider::Rotary);

    addAndMakeVisible (delaySlider = new Slider());
    delaySlider->setSliderStyle (Slider::Rotary);
    
    //add slider attachments
    gainSliderAttachment = new AudioProcessorValueTreeState::SliderAttachment (owner.pluginState, "gainParam", *gainSlider);
    delaySliderAttachment = new AudioProcessorValueTreeState::SliderAttachment (owner.pluginState, "delayParam", *delaySlider);

	// add buttons
	addAndMakeVisible (undoButton = new TextButton ("Undo"));
	addAndMakeVisible (redoButton = new TextButton ("Redo"));


    // add some labels for the sliders..
    gainLabel.attachToComponent (gainSlider, false);
    gainLabel.setFont (Font (11.0f));

    delayLabel.attachToComponent (delaySlider, false);
    delayLabel.setFont (Font (11.0f));

    // add the midi keyboard component..
    addAndMakeVisible (midiKeyboard);

    // add a label that will display the current timecode and status..
    addAndMakeVisible (timecodeDisplayLabel);
    timecodeDisplayLabel.setColour (Label::textColourId, Colours::blue);
    timecodeDisplayLabel.setFont (Font (Font::getDefaultMonospacedFontName(), 15.0f, Font::plain));

    // set resize limits for this plug-in
    setResizeLimits (450, 200, 800, 300);

    // set our component's initial size to be the last one that was stored in the filter's settings
    setSize (owner.lastUIWidth,
             owner.lastUIHeight);

	// add listeners for sliders and buttons
	gainSlider->addListener (this);
	delaySlider->addListener (this);
	undoButton->addListener (this);
	redoButton->addListener (this);

    // start a timer which will keep our timecode display updated
    startTimer (0, 30);
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
    g.setGradientFill (ColourGradient (Colours::white, 0, 0,
                                       Colours::lightgrey, 0, (float) getHeight(), false));
    g.fillAll();
}

void JuceDemoPluginAudioProcessorEditor::resized()
{
    // This lays out our child components...

    Rectangle<int> r (getLocalBounds().reduced (8));

    timecodeDisplayLabel.setBounds (r.removeFromTop (26));
    midiKeyboard.setBounds (r.removeFromBottom (70));

    r.removeFromTop (30);
    Rectangle<int> sliderArea (r.removeFromTop (50));
    gainSlider->setBounds (sliderArea.removeFromLeft (jmin (180, sliderArea.getWidth() / 2)));
    delaySlider->setBounds (sliderArea.removeFromLeft (jmin (180, sliderArea.getWidth())));

	undoButton->setBounds (delaySlider->getRight(), delaySlider->getY(), 40, 20);
	redoButton->setBounds (undoButton->getX(), undoButton->getBottom(), 40, 20);

    getProcessor().lastUIWidth = getWidth();
    getProcessor().lastUIHeight = getHeight();
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::timerCallback (int ID)
{
	if (ID == 0)
	{
		updateTimecodeDisplay (getProcessor().lastPosInfo);
		setUndoRedoButtons();
	}
	else if (ID == 1)
	{
		getProcessor().pluginState.undoManager->beginNewTransaction();
		stopTimer(1);
	}
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static String timeToTimecodeString (double seconds)
{
    const int millisecs = roundToInt (seconds * 1000.0);
    const int absMillisecs = std::abs (millisecs);

    return String::formatted ("%02d:%02d:%02d.%03d",
                              millisecs / 360000,
                              (absMillisecs / 60000) % 60,
                              (absMillisecs / 1000) % 60,
                              absMillisecs % 1000);
}

// quick-and-dirty function to format a bars/beats string
static String quarterNotePositionToBarsBeatsString (double quarterNotes, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|000";

    const int quarterNotesPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (quarterNotes, quarterNotesPerBar) / quarterNotesPerBar) * numerator;

    const int bar    = ((int) quarterNotes) / quarterNotesPerBar + 1;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));

    return String::formatted ("%d|%d|%03d", bar, beat, ticks);
}

// Updates the text in our position label.
void JuceDemoPluginAudioProcessorEditor::updateTimecodeDisplay (AudioPlayHead::CurrentPositionInfo pos)
{
    MemoryOutputStream displayText;

    displayText << "[" << SystemStats::getJUCEVersion() << "]   "
                << String (pos.bpm, 2) << " bpm, "
                << pos.timeSigNumerator << '/' << pos.timeSigDenominator
                << "  -  " << timeToTimecodeString (pos.timeInSeconds)
                << "  -  " << quarterNotePositionToBarsBeatsString (pos.ppqPosition,
                                                                    pos.timeSigNumerator,
                                                                    pos.timeSigDenominator);

    if (pos.isRecording)
        displayText << "  (recording)";
    else if (pos.isPlaying)
        displayText << "  (playing)";

    timecodeDisplayLabel.setText (displayText.toString(), dontSendNotification);
}

// callback when undo or redo buttons are clicked
void JuceDemoPluginAudioProcessorEditor::buttonClicked (Button* button)
{
	if (button == undoButton)
	{
		if (getProcessor().pluginState.undoManager->canUndo())
			getProcessor().pluginState.undoManager->undo();
	}
	else if (button == redoButton)
	{
		if (getProcessor().pluginState.undoManager->canRedo())
			getProcessor().pluginState.undoManager->redo();
	}
}

// When a slider drag ends, the timer is started. 
// If another drag begins and ends within this time the timer will be restarted and the actions will be grouped as one transaction
void JuceDemoPluginAudioProcessorEditor::sliderDragEnded (Slider* /*slider*/)
{
	startTimer (1, 50);
}

// enables or disables undo and redo buttons depending on whether undo and redo actions exist
void JuceDemoPluginAudioProcessorEditor::setUndoRedoButtons()
{
	if (getProcessor().pluginState.undoManager->canUndo() && !undoButton->isEnabled())
		undoButton->setEnabled (true);
	else if (!getProcessor().pluginState.undoManager->canUndo() && undoButton->isEnabled())
		undoButton->setEnabled (false);

	if (getProcessor().pluginState.undoManager->canRedo() && !redoButton->isEnabled())
		redoButton->setEnabled (true);
	else if (!getProcessor().pluginState.undoManager->canRedo() && redoButton->isEnabled())
		redoButton->setEnabled (false);

}


// not being used, but pure virtual function requires overriding
void JuceDemoPluginAudioProcessorEditor::sliderValueChanged (Slider * slider)
{
}
